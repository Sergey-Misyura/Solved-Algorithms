# считываем данные
K = int(input().strip())  # число тестов в мультитесте
answer = [None] * K  # массив ответов на тесты
# цикл тестов
for num in range(K):
    seq = list(map(int, input().split()))  # данные теста - N - число пар чисел A, B; пары A,B - время прихода на дежурство и ухода
    security = []  # массив приходов и уходов охранников
    # добавляем данные в массив событий - приход охранника '-1' раньше ухода '1'
    for i in range(1, len(seq), 2):
        security.append((seq[i], -1))
        security.append((seq[i + 1], 1))

    # сортируем массив событий
    security.sort()
    # если приход первого позже 0 и уход последнего раньше 10000 - 'Wrong Answer'
    if security[0][0] > 0 or security[-1][0] < 10000:
        answer[num] = 'Wrong Answer'
    # иначе, общий случай
    else:
        count = 1  # текущее количество охранников
        answer[num] = 'Accepted'  # инициализация ответа для текущего теста
        prev_event = security[0]  # переменная с предыдущим событием
        # проходим по массиву событий с индекса 1
        for event in security[1:]:
            count -= event[1]  # обновление количество охранников
            # если 2 одинаковых события наступили одновременно (так как для выполнения условия уникальности и непокрытия
            # они должны чередоваться) или одновременно охранников 0 или больше 2 при времени != 10000 (т.е. либо никого
            # нет, либо одни покрывают других, только в 10000 может уйти последний), тогда 'Wrong Answer' и break
            if event == prev_event or ((count < 1 or count > 2) and event[0] != 10000):
                answer[num] = 'Wrong Answer'
                break
            # обновление предыдущего события
            prev_event = event

# ответ
print('\n'.join(answer))

