from math import ceil

# считываем данные
n, a, b, w, h = map(int, input().split())  # n модулей, a, b - размеры модуля, w, h - размеры поля

# используем ПРАВЫЙ бин поиск доп защиты для расстановки: a - высота, b - ширина
lf, rg = 0, (max(w, h) - min(a, b)) // 2  # границы доп защиты
while lf < rg:
    # считаем центр
    mid = (lf + rg) // 2 + 1
    # считаем ряды домов
    rows = h // (a+2*mid)
    # если рядов не получили, уменьшаем правую границу доп защиты
    if rows == 0:
        rg = mid - 1
    # иначе считаем столбцы домов
    else:
        cols = ceil(n/rows)
        # если получили столбцы и уместили дома с защитой - сдвигаем lf на mid
        if cols > 0 and cols * (b+2*mid) <= w:
            lf = mid
        # если дома не поместились, сдвигаем правый указатель на mid - 1
        else:
            rg = mid - 1

lf_forward = lf  # сохраняем полученное значение доп защиты

# используем ПРАВЫЙ бин поиск доп защиты для расстановки, повернув дома на 90: a - ширина, b - высота
lf, rg = 0, (max(w, h) - min(a, b)) // 2 # границы доп защиты
while lf < rg:
    # считаем центр
    mid = (lf + rg) // 2 + 1
    # считаем ряды домов
    rows = h // (b+2*mid)
    # если рядов не получили, уменьшаем правую границу доп защиты
    if rows == 0:
        rg = mid - 1
    # иначе считаем столбцы домов
    else:
        cols = ceil(n/rows)
        # если получили столбцы и уместили дома с защитой - сдвигаем lf на mid
        if cols > 0 and cols * (a+2*mid) <= w:
            lf = mid
        # если дома не поместились, сдвигаем правый указатель на mid - 1
        else:
            rg = mid - 1

# ответ - максиально возможный слой защиты
print(max(lf, lf_forward))