# считываем данные
x = input().strip()  # слово х
z = input().strip()  # требуемое сообщение z

answer = 0  # переменная ответа
# проходим от конца по элементам z, сравнивая от конца с элементами х
for zstart in range(len(z) - 1, -1, -1):

    zpos = zstart  # начальная позиция в z для внутреннего цикла
    xpos = len(x) - 1  # позиция в x для внутреннего цикла
    flag = True  # флаг соответствия строки z строке х
    # для каждого zpos в каждом zstart до начала z, проверяем является ли текущая буква буквой из зацикленного х
    for zpos in range(zstart, -1, -1):
        # через xpos % len(x) зацикливается строка x
        # если символ с zpos не совпал в xpos - флаг соответствия False, break, переходим к новой zstart
        if z[zpos] != x[xpos % len(x)]:
            flag = False
            break
        # иначе уменьшаем xpos
        else:
            xpos -= 1
    # если где либо был флаг несоответствия - обновляем ответ, границу неповторяемой строки, break
    if flag:
        answer = zstart + 1
        break

# ответ
print(z[answer:])

