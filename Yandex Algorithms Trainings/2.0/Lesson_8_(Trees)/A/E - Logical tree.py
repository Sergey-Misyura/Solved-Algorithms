# считываем данные
n, v = map(int, input().split())
operations = [0] * (n + 1)  # массив операций дерева
pos_change = [0] * (n + 1)  # массив смен позиций для вершин дерева
changes = [[float('inf')] * (n + 1), [float('inf')] * (n + 1)]  # двумерный массив количеств смен: [для получения 0, для получения 1] в узле i
for i in range(1, (n - 1) // 2 + 1):  # считываем о внутренних вершинах
    operations[i], pos_change[i] = map(int, input().split())
for i in range((n + 1) // 2, n + 1):  # считываем информацию о листьях
    value = int(input())
    changes[value][i] = 0
    changes[1 - value][i] = float('inf')
for i in range((n - 1) // 2, 0, -1):
    # для операции 'или'
    if operations[i] == 0 or pos_change[i] == 1:  # записано 'или' либо можем поменять на 'или'
        add_count = 0  # добавляемое количество замен
        if operations[i] == 1:  # если операция 'и', а мы можем заменить, число операций = 1
            add_count = 1
        # для получения 1 нужна только 1 в любом из поддеревьев
        changes[1][i] = min(changes[1][2 * i], changes[1][2 * i + 1]) + add_count  # минимальное число операций для 1: минимум из левого[1] и правого[1] поддеревьев плюс add_count
        # для получения 0 нужны 0 в обоих поддеревьях
        changes[0][i] = changes[0][2 * i] + changes[0][2 * i + 1] + add_count  # минимальное число операций для 0: сумма замен в левом[0] и правом[0] поддеревьях плюс add_count
    # для операции 'и'
    if operations[i] == 1 or pos_change[i] == 1:  # записано 'и' либо можем поменять на 'и'
        add_count = 0  # добавляемое количество замен
        if operations[i] == 0:  # если операция 'или', а мы можем заменить, число операций = 1
            add_count = 1
        # для получения 1 нужны 1 в обоих поддеревьях
        # минимальное число операций для 1: мининимум из уже посчитанного changes[1][i] и суммы левого[1] и правого[1] поддеревьев плюс add_count
        changes[1][i] = min(changes[1][i], changes[1][2 * i] + changes[1][2 * i + 1] + add_count)
        # для получения 0 нужен только 0 в любом из поддеревьев
        # минимальное число операций для 0: мининимум из уже посчитанного changes[0][i] и минимума из левого[1] и правого[1] поддеревьев плюс add_count
        changes[0][i] = min(changes[0][i], min(changes[0][2 * i], changes[0][2 * i + 1]) + add_count)

# ответ, количество операций для получения v значения корня
if changes[v][1] < float('inf'):
    print(changes[v][1])
else:
    print('IMPOSSIBLE')