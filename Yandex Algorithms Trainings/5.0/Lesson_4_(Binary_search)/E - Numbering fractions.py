# из-за проблем с float решение на python не проходит
# переписано на cpp - работает

# считываем данные
n = int(input().strip())  # порядковый номер числа

diag = int((n * 2) ** 0.5)  # находим диагональ искомого числа, округляя вниз
if not diag * (diag + 1) / 2 >= n:  # если не покрыли, округляя вниз, переходим к следующей диагонали
    diag += 1

if diag == 1:  # ответ при диагонали равной 1
    print('1/1')
else:  # общий случай
    prev_nums_count = int((diag - 1) * diag / 2)  # общее количество чисел до текущей диагонали
    diag_idx = n - prev_nums_count  # индекс числа на текущей диагонали
    if diag % 2:  # если диагональ четная, идем снизу вверх
        num = diag_idx  # числитель равен индексу
        denom = diag + 1 - num  # знаменатель равен номер диагонали - числитель - 1
    else:  # если диагональ нечетная, идем сверху вних
        denom = diag_idx  # знаменатель равен индексу
        num = diag + 1 - denom  # числитель равен номер диагонали - знаменатель - 1
    # ответ
    print(f'{num}/{denom}')