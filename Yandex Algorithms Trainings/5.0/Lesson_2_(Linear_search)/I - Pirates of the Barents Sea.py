# считываем данные
N = int(input().strip())  # количество клеток
ships = [0] * N  # массив координат кораблей
for i in range(N):
    row, col = map(int, input().split())
    ships[i] = (row - 1, col - 1)

min_all_moves = float('inf')  # переменная ответа
for col in range(N):  # проходим по колонкам поля
    # для подсчета минимального числа ходов отсортируем корабли так чтобы они шли по строкам сверху вниз,
    # а корабли в одной строке были расположены от ближайших к целевому столбцу до дальних
    ships.sort(key=lambda ship: (ship[0], abs(col - ship[1])))
    # теперь проходя по целевому столбцу сверху вниз, корабли отсортированы также, ставим в текущее место очередной корабль из ships - ближайший к столбцу
    # таким образом количество ходов будет соответствовать минимальному, потому что нет разницы ближний или дальний корабль ставить на оптимальное место -
    # сумма их ходов будет одна и та же, следовательно выбираем вариант от мин к макс
    # при других методах выставления (например, поиск блищайшего свободного места в столбце от строки текущего корабля) возможны перехлесты и не оптимальный ответ
    cur_all_moves = 0  # текущее число ходов
    for i in range(N):  # проходим по столбцу
        cur_all_moves += abs(col - ships[i][1]) + abs(i - ships[i][0])  # увеличиваем cur_all_moves на число затраченных ходов

    min_all_moves = min(min_all_moves, cur_all_moves)  # обновляем ответ
# ответ
print(min_all_moves)


