def here_rectangle(x_start, x_end):  # функция определяющая есть ли прямоугольник в заданной области, а также пуста ли область
    here_rectangle = True  # флаг найденного прямоугольника
    empty_area = False  # флаг найденной пустой области
    x_rec_start, len_rec = -1, 0  # начальная x координата прямоугольника, длина искомого прямоугольника
    cur_x, cur_y = x_start, 0  # текущие x, y в переданной области
    # находим начало прямоугольника
    while cur_y < m and x_rec_start == -1:  # пока не нашли начало и не вышли за границу проходим по строкам
        cur_x = x_start  # задаем начальное x для каждой новой строки
        while cur_x <= x_end and x_rec_start == -1:  # пока не нашли начало и не вышли за границу проходим элементам в строке
            if grid[cur_y][cur_x] == '#':  # если нашли начало - сохраняем его, увеличиваем длину на 1
                x_rec_start = cur_x
                len_rec += 1
            cur_x += 1
        cur_y += 1

    cur_y -= 1  # возвращаемся на строку вверх - начало прямоугольника
    if x_rec_start == -1:  # если не нашли закрашенную клетку - тогда область пустая, обновляем флаги here_rectangle, empty_area
        here_rectangle = False
        empty_area = True
    else:  # если есть закрашенная клетка
        cur_x = x_rec_start + 1  # текущая клетка по х
        # переходим по строке - началу закрашенной области, считаем предполагаемую длину прямоугольника
        while cur_x <= x_end and grid[cur_y][cur_x] == '#':  # пока не вышли за границы и пока есть закрашенные клетки
            len_rec += 1
            cur_x += 1

        space = False  # флаг найденного пустого места в строке, указывает на начало пустой строки под прямоугольником
        # проходим по области, проверяем что ТОЛЬКО внитри прямоугольника ВСЕ клетки закрашены
        for y in range(cur_y, m):  # итерируемся по строкам
            for x in range(x_start, x_end + 1):  # итерируемся по клеткам в строке
                if grid[y][x] == '#':  # когда нашли закрашенную клетку
                    if space or x < x_rec_start or x > x_rec_start + len_rec -1:  # если уже началась пустая строка, либо она за границами прямоугольника - флаг here_rectangle False
                        here_rectangle = False
                        break
                else:  # когда нашли пустую клетку
                    if x >= x_rec_start and x <= x_rec_start + len_rec - 1:  # если она в х границах прямоугольника - меняем флаг space = True
                        space = True
                    # если она в границах и за левой х границей, а перед ней '#', то есть 'прервала' прямоугольник - флаг here_rectangle = False
                    if x > x_rec_start and x <= x_rec_start + len_rec - 1 and grid[y][x - 1] == '#':
                        here_rectangle = False
                        break
    # возвращаем флаги наличия прямоугольника и наличия пустой области
    return here_rectangle, empty_area


def paint_rectange(x_start, x_end, y_start, y_end, color):  # функция закраски прямоугольника в заданной области, значения включительно
    # проходим по клетка - видим '#' - меняем на color
    for y in range(y_start, y_end + 1):
        for x in range(x_start, x_end + 1):
            if grid[y][x] == '#':
                grid[y][x] = color


# считываем данные
m, n = map(int, input().split())  # строки, столбцы рисунка
grid = [''] * m  # сетка рисунка

# Само Решение: Разрезание картины на две части по точкам либо пересечения либо конца прямоугольников,
# проверка каждой отрезанной области на наличие в них прямоугольников, вывод/перерисовка, ответ
# Сначала режем вертикально по точкам начала и конца первого отрезка в первой закрашенной строке, проверяем;
# Если не помогло, проходим по строкам сверху вниз взяв максимальные границы закрашенной области - ищем точку перехода
# или разрыва прямоугольников в столбце, режем по ней горизонтально, если нашли - проверка, вывод/перерисовка, ответ,
# если не нашли ответ NO

y_top, y_down = 300, -1  # верхняя граница y закрашенной области, нижняя граница y закрашенной области (ограничение 200)
x_left_up, x_right_up, x_left_down, x_right_down = 300, -1, 300, -1  # x границы для первого закрашенного отрезка в строках y_top, y_down

top_space = False  # переменная встреченного пробела в строке y_top, для остановки обновления x_right_up
for i in range(m):  # заполняем сетку, считаем границы рисунка
    row = list(input().strip())
    grid[i] = row
    for j in range(n):  # проходим по строке
        if row[j] == '#':  # если встретили закрашенную область
            y_top = min(y_top, i)  # обновляем верхнюю границу закрашенной области
            if i > y_down:  # при новом i обновляем нижнюю границу закрашенной области, а также возвращаем в исходное x_left_down, x_right_down, bot_space
                y_down = i
                x_left_down, x_right_down = 300, -1
                bot_space = False
            if i == y_top:  # если мы в верхней строке
                x_left_up = min(x_left_up, j)  # сохраняем начало закрашенной области (просто оставил min, лучше по-другому)
                if j == x_left_up:  # в начале x_left_up x_right_up совпадают
                    x_right_up = x_left_up
                elif j > x_left_up and not top_space:  # далее пока не встретили пробел увеличиваем правую границу
                    x_right_up = j
            if i == y_down:
                # здесь крайняя левая и крайняя правая границы нужны не для разреза, а для дальнейшего использования в условии одной точки и прохода по вертикали
                # поэтому ищем крайние закрашенные точки
                x_left_down, x_right_down = min(x_left_down, j), max(x_right_down, j)
        else:  # если встретили пустую область
            if i == y_top and j > x_left_up:  # и если находимся в верхней строке закрашенной области, после начала закрашенной области, обновляем top_space
                top_space = True

if x_left_up == 300 or x_left_up == x_right_up == x_left_down == x_right_down and y_top == y_down:  # если закрашенная область одна клетка, либо нет области - ответ NO
    print('NO')
else:  # иначе если закрашена более чем 1 клетка
    # -----ВЕРТИКАЛЬНОЕ разбиение по левой границе x_left_up отрезка
    lf_rec, lf_empty = here_rectangle(0, x_left_up - 1)  # наличие прямоугольника в левой части, наличие полностью пустого места в левой части
    rg_rec, rg_empty = here_rectangle(x_left_up, n - 1)  # наличие прямоугольника в правой части, наличие полностью пустого места в правой части
    if lf_rec and rg_rec:  # если слева и справа прямоугольники, закрашиваем, ответ
        print('YES')
        paint_rectange(0, x_left_up - 1, 0, m - 1, 'a')
        paint_rectange(x_left_up, n - 1, 0, m - 1, 'b')
        print(*[''.join(row) for row in grid], sep='\n')
    elif lf_empty and rg_rec:  # если слева пустое место, а справа прямоугольник - печатаем YES
        print('YES')
        # делим область и закрашиваем
        if x_left_up != x_right_up:  # если весь прямоугольник не столбец - делим на 2 прямоугольника: первый шириной 1 клетка
            paint_rectange(0, x_left_up, 0, m - 1, 'a')
            paint_rectange(x_left_up + 1, n - 1, 0, m - 1, 'b')
            print(*[''.join(row) for row in grid], sep='\n')
        else:  # если прямоугольник столбец - делим на 2 прямоугольника: первый - 1 клетка
            paint_rectange(x_left_up, x_left_up, 0, y_top, 'a')
            paint_rectange(x_left_up, x_left_up, y_top + 1, m - 1, 'b')
            print(*[''.join(row) for row in grid], sep='\n')
    else:  # -----ВЕРТИКАЛЬНОЕ разбиение по правой границе x_right_up отрезка
        lf_rec, lf_empty = here_rectangle(0, x_right_up)  # прямоугольник слева, пустое место слева
        rg_rec, rg_empty = here_rectangle(x_right_up + 1, n - 1)  # прямоугольник справа, пустое место справа
        if lf_rec and rg_rec:  # если слева и справа получились прямоугольники - закрашиваем, ответ
            print('YES')
            paint_rectange(0, x_right_up, 0, m - 1, 'a')
            paint_rectange(x_right_up + 1, n - 1, 0, m - 1, 'b')
            print(*[''.join(row) for row in grid], sep='\n')
        else:  # -----ГОРИЗОНТАЛЬНОЕ разбиение
            cur_x_left, cur_x_right = min(x_left_up, x_left_down), max(x_right_up, x_right_down)  # максимальные границы по х закрашенной области
            y_mid = y_top + 1  # линия проверки, граница разреза
            # опускаясь двумя указателями находим переход или обрыв от одного прямоугольника к другому
            # условия выхода: переход любого указателя от '.' к '#' или наоборот, конец сетки
            while y_mid < m and grid[y_mid][cur_x_left] == grid[y_mid - 1][cur_x_left] and grid[y_mid][cur_x_right] == grid[y_mid - 1][cur_x_right]:
                y_mid += 1

            if y_mid == m:  # если мы прошли до конца сетки, а вертикальное разбиение ничего изначально не дало, значит внутри фигуры пробелы - ответ NO
                print('NO')
            else:  # если мы нашли переход или обрыв
                y_mid -= 1  # возвращаем y_mid на шаг назад для в указания границы разрезания
                grid = list(map(list, zip(*grid)))[::-1]  # поворачиваем матрицу для выполнения функции, разбиваем по найденной границе
                n, m = m, n  # при повороте матрицы меняем местами переменные высоты и ширины
                lf_rec, lf_empty = here_rectangle(0, y_mid)  # прямоугольник слева, пустое место слева
                rg_rec, rg_empty = here_rectangle(y_mid + 1, n - 1)  # прямоугольник справа, пустое место справа
                if lf_rec and rg_rec:  # если слева и справа получились прямоугольники, ответ YES перекрашиваем, поворачиваем матрицу назад, выводим
                    print('YES')
                    paint_rectange(0, y_mid, 0, m - 1, 'a')
                    paint_rectange(y_mid + 1, n - 1, 0, m - 1, 'b')
                    grid = list(zip(*reversed(grid)))
                    print(*[''.join(row) for row in grid], sep='\n')
                else:  # если вышестоящие условия не выполнились, значит не два прямоугольника, ответ NO
                    print('NO')
