# считываем данные
L, x1, v1, x2, v2 = map(int, input().split())  # длина окружности, точка старта бегуна 1, скорость 1, точка старта бегуна 2, скорость 2

# рассмотрим разные варианты x1,x2,v1,v2
if v1 == 0 and v2 == 0:  # если скорость обоих участников нулевая
    if x1 == x2 or x1 == L - x2 or x2 == L - x1:  # если точки равноудаленны - выводим YES 0
        print('YES')
        print(0)
    else:  # иначе выводим NO
        print('NO')
elif v1 == v2:  # если скорость обоих участников одинакова и бег направлен в одну сторону
    if x1 == x2 or x1 == L - x2 or x2 == L - x1:  # если точки равноудаленны - выводим YES 0
        print('YES')
        print(0)
    else:  # иначе считаем время
        max_x, min_x = max(x1, x2), min(x1, x2)  # упорядочиваем точки
        # здесь из точек составляем отрезок, который будем двигать к вычисленным нужным местам на окружности
        if v1 > 0:  # при движении по часовой стрелке
            head = 'MAX'  # выбираем головной точкой, точку с макс X
            dist = max_x - min_x  # расстояние между точками
            if L - dist < dist:  # если кратчайшее расстояние проходит через 0, меняем головную точку на мин, меняем dist
                head = 'MIN'
                dist = L - dist
            first_point = dist / 2  # первый вариант точки расположения head при движении по часовой
            second_point = L / 2 + first_point  # второй вариант точки расположения head при движении по часовой
            if head == 'MIN':  # если головная точка MIN - двигаем ее к первой точке и находим время
                t = (first_point - min_x) / v1
                if t < 0:  # если MIN находится за первой точкой - двигаем ко второй
                    t = (second_point - min_x) / v1
            else:  # иначе, если головная точка MAX - двигаем ее ко второй точке и находим время
                t = (second_point - max_x) / v1
                if t < 0:  # если MAX находится за второй точкой - двигаем к первой
                    t = (L + first_point - max_x) / v1
            print('YES')
            print('%.10f' % (round(t, 10)))
        else:  # аналогично при движении против часовой стрелки, начинаем с точки MIN
            head = 'MIN'
            dist = max_x - min_x
            if L - dist < dist:
                head = 'MAX'
                dist = L - dist
            first_point = L / 2 - dist / 2
            second_point = - dist / 2
            if head == 'MIN':
                t = (first_point - min_x) / v1
                if t < 0:
                    t = (second_point - min_x) / v1
            else:
                t = ((L + second_point) - max_x) / v1
                if t < 0:
                    t = (first_point - max_x) / v1
            print('YES')
            print('%.10f' % (round(t, 10)))
elif v1 == -v2:  # если скорости бегунов обратные и направление встречное
    if x1 > x2:  # если первый бегун дальше по кругу
        if v1 < 0:  # при скорости первого бегуна против часовой стрелки
            t = (x1 - x2) / (v2 * 2)  # искомое время
        else:  # при движении первого бегуна по часовой стрелке
            t = (L - (x1 - x2)) / (v1 * 2)
    else:  # иначе, если второй бегун дальше по кругу, расчет аналогично первому
        if v2 < 0:
            t = (x2 - x1) / (v1 * 2)
        else:
            t = (L - (x2 - x1)) / (v2 * 2)
    print('YES')
    print('%.10f' % (round(t, 10)))
else:  # иначе, если скорости разные
    # при движении по окружности они могут быть равноудалены от 0 в двух точках
    t1 = (x2 - x1) / (v1 - v2)  # время до первой точки равноудаленности
    t2 = (L - x2 - x1) / (v1 + v2)  # время до второй точки равноудаленности
    # если время получилось отрицательным - добавляем время на проход круга, пока t не станет положительным
    while t1 < 0:
        t1 += abs(L / (v1 - v2))
    while t2 < 0:
        t2 += abs(L / (v1 + v2))
    print('YES')  # ответ
    print('%.10f' % (round(min(t1, t2), 10)))